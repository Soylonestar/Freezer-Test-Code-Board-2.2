/*
 * main.c
 *
 * Created: 6/14/2024 12:06:48 PM
 *  Author: agarciasampedroperez
 */ 

//////MEGA_1284P Board////////////

#define F_CPU 11059200UL //system clock 11.0592MHz
#define USART_1_BAUD 9600 //baud rate of USART

#include <avr/interrupt.h>
#include <avr/io.h>
#include <stdio.h>
#include <util/delay.h>
#include <string.h>
#include <stdbool.h>

uint16_t adc_data;

int main(void)
{
	sei(); //enabling the Global Interrupt bit
	
    while(1)
    {
       ;
    }
}

/** \brief Function to setup USART1.
 *  //////We DO NOT screw with this because this communicates the USB to Board Controller to Atmega1284P//////
 * 
 * USART1 is used to communicate with the board controller (AT32UC3256B1).
 *
 * USART1 configuration:
 * - 57600 baud //used the equation to calculate this...
 * - No parity
 * - 1 stop bit
 * - 8-bit character size
 */
void usart1_init(void)
{
	// Make sure I/O clock to USART1 is enabled
	PRR0 &= ~(1 << PRUSART1);

	// Set baud rate
	UBRR1 = ((float)(F_CPU / (16 * (float)USART_1_BAUD)) - 1);

	// Clear USART Transmit complete flag, normal USART transmission speed
	UCSR1A = (1 << TXC1) | (0 << U2X1);

	// Enable receiver and transmitter
	UCSR1B = (1 << RXEN1) | (1 << TXEN1);

	// Asynchronous mode, no parity, 1 stop bit, character size = 8-bit
	UCSR1C = (1 << UCSZ11) | (1 << UCSZ10) | (0 << UCPOL1);
}

/** \brief Function to setup ADC.
 *
 * ADC configuration:
 * - Internal 2.56V bandgap voltage with 100nF cap at AREF pin as reference
 * - 172.8kHz ADC frequency
 */
void adc_init(void)
{
	// Make sure I/O clock to the ADC is enabled //don't normally need to do this because this initializes at 0 (enabled)
	PRR0 &= ~(1 << PRADC);

	// Digital Input enable
	//DIDR0 = 0x00; //gonna see why we need this on, I'm not trying to use an input
	
	DIDR0 |= (1 << ADC0D); 	//Disable Digital Input

	// Use internal 2.56V bandgap reference with external 100nF cap at AREF pin
	ADMUX = (1 << REFS1) | (1 << REFS0);

	// Enable ADC, ADC frequency set to 16MHz/128 = 125kHz
	ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);
}

/**
 * \brief Function to start ADC conversion.
 *
 * This function will do ADC_NUM_OVERSAMPLINGx oversampling. Per default it
 * will perform 16x oversampling.
 *
 * \param channel    ADC channel number
 *
 * \return adc_data  Result from ADC reading of selected ADC channel
 */
void read_adc(adc_data)
{
	for (int i = 0 ; i < 16 ; i++) {
		//Start single conversion
		ADCSRA |= (1 << ADSC);

		//Wait for conversion complete
		while(!(ADCSRA & (1 << ADIF)));

		//Read ADC conversion result
		adc_data += ADC;
	}
	//takes the average of the 16 data bits...
	adc_data = adc_data/16;

	return adc_data;
}

/**
 * \brief Function to read Light sensor ADC value.
 */
static void read_light_sensor(void)
{
	uint16_t light_sensor_data;
	// Read LIGHT SENSOR
	light_sensor_data = read_adc(LIGHT_SENSOR);

	// Send LIGHT_SENSOR_data to PC
	printf("LIGHT SENSOR ADC value: %4d\r\n", light_sensor_data);
}

ISR(TIMER1_COMPB_vect) //OC1B pin
{
	// Turn on LEDs (make sure PORTB0 is set as output)
	DDRB |= (1 << DDB0);
	
	LED_toggle();
	
	TIFR1 |= (1 << OCF1B); //Clear the Output Compare B Match Flag
}

void LED_toggle (void)
{
	PORTB ^= (1 << PORTB3) | (1 << PORTB2) | (1 << PORTB1) | (1 << PORTB0);
}

/** \brief Function to setup timer1 as a time base for the touch lib.
 *
 * In this mode Timer1 is used to generate PWM signal on the LEDs.
 *
 * Timer1 configuration:
 * - CTC mode (clear on compare match A)
 * - clkIO/8 prescaling
 */
void timer1_init(void) //16-bit timer; OC1B pin, Timer 1 and Channel B
{
	// Make sure I/O clock to timer1 is enabled
	PRR0 &= ~(1 << PRTIM1);

	// Enable timer1 output compare match B interrupt ISR
	TIMSK1 = (1 << OCIE1B); // this is an interrupt bit mask

	// Set timer compare value (how often timer ISR will fire)
	OCR1A = 21599;

	//setting for Toggle OC1B on Compare Match; the rest initializes at 0
	TCCR1A |= (1 << COM1B0); 

	// Timer1 mode = CTC (count up to compare value, then reset); the rest initializes at 0
	TCCR1B |= (1 << WGM12);

	// Timer1 prescaler = system clock / 256
	TCCR1B |= (1 << CS12) | (0 << CS11) | (0 << CS10);
}
